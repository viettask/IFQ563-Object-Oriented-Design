Read Chapter 14 Files and Streams (Farrell, 2018, pp. 646–653).
https://rl.talis.com/3/qut/items/40EE2A37-3E0E-0BD1-EE96-80E763F5A897.html?lang=en&login=1

Additional resources:

1. File class (Microsoft, 2020a)
   https://qut.rl.talis.com/link?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fdotnet%2Fapi%2Fsystem.io.file%3Fview%3Dnetcore-3.1&sig=c0cc7363bdb17ef55ebb095bb104184cf23767f8bda834c2237610376f18a3bb
2. Directory class (Microsoft, 2020b)
   https://qut.rl.talis.com/link?url=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fdotnet%2Fapi%2Fsystem.io.directory%3Fview%3Dnetcore-3.1&sig=fa08813549516e99baa59fe7152e9f12ae582a21013a7e1332612f5ec6d2ddf5

Temporary storage (Computer) = RAM (Random Access Memory) -> type of storage : volative
Permanent storage -> type of storage : nonvolative

Files to store data

1. Text files : ASCII, Unicode, data files, .cs extensions
2. Binary files: encoded as text. Ex: images, music, videos, .exe

Common chracteristics (Text & Binary)

1. Name
2. Specific time of creation
3. Size: Byte/ kilobytes/ megabytes/gigabytes

PL (programming languages)

Common programming paradigms in high-level PL include:

1. Imperative: (Mệnh lệnh)
   Imperative, in which the programmer instructs the machine how to change its state. 
	They can be: + procedural, which groups instructions into procedures, or + object-oriented, which groups instructions together with the part of the state they operate on.
2. Declarative (Khai báo)
   Declarative, in which the programmer merely declares properties of the desired result, but not how to compute it. 
	They can be: + functional, in which the desired result is declared as the value of a series of function applications + logic, in which the desired result is declared as the answer to a question about a system of facts and rules + mathematical, in which the desired result is declared as the solution of an optimisation problem.

Fact: OOP is intuitively and generally more productive than C because objects are computational components that model real-world entities.​ However, OO programs do NOT necessarily run faster than procedural languages. In fact, OO programs are generally slower than C programs.

Object technology is used at all levels of software development.
1. Analysis and design: Design time objects reflect real-world entities
2. Programming: Run-time objects provide computational behaviours
3. System support: Distributed objects, object-based file stores, concurrency, security, garbage collection.

4 Key concerns for OO software:
1. Correctness: Behave according to specification
2. Robustness: Cope with abnormal situations
3. Extendibility: Ease of adapting to changes in the specification (Focused)
4. Reusability: Usable in different situations. (Focused)
	Reusability in OO is often achieved by inheritance in OOPL that allows users to extract common features from similar objects
	So that they may be reused by different applications through a common interface.
	It's also related to extendibility, because
	common interfaces hide implementation details, allowing the implementation to be changed without affecting the users of the interfaces.


Basic OO concepts:
1. Object: encapsulates some data and code
	+ The object takes requests from other objects but does not expose the details of its data or code to them.
	+ The object alone is responsible for its own state, exposing a public interface to clients, and declaring private fields 
		and methods that make up its implementation
	+ The client depends on the (hopefully) simple public interface and does not know about or depend on the details of the implementation.
	
	+  Objects model runtime entities, including:
		+ Encapsulation of data + operations (Tính đóng gói)
		+ Operations (methods and calls, events and messages)
		+ information hiding (separation of public interface from internal representation)
2. Classes 
	+ Classes define objects -> objects are instances of classes.
	+ Objects of the same class have the same structure and operations.
3. Polymorphism (Tính đa hinh)
	+ Different classes of objects may have common interface.
	+ Using the inheritance mechanism.
	+ Inheritance allow new classes (subclass or child class or derived class) to extend existing classes(superclass, or base class, or parent class)
		, forming them into a hierarchy of classes.
	+ Subclasses can inherit methods from the superclass, or redefine (override) the methods in base classes by replacing the implementation of the methods
		that have been inherited.
	= Define subclasses (specialisation and extension of objects), method redefinition (overriding) and dynamic binding
4. Abstract classes
	+ No instance, common abstraction for different types of objects.

When using classes and objects in C#:
1. Almost everything is an object:
	+ C# is more of a pure object-oriented programming language (OOPL)
	+ Exceptions include primitive types
2. Running C# program:
	+ a bunch of objects telling each other what to do by sending messages (through method calls)
3. Every object has a type (class)
	+ An object is an instance of a class.
4. A class is a collection of data and operations
5. C# is an imperative and strongly typed language = All data and reference types in fields and methods (parameters and returns) must be explicitly typed.
	
Access modifiers to set the boundaries in a class
1. Public: can be accessed by anyone anywhere.  Someone who tries to access a private member will get a compile-time error
2. Private: can only be accessed from with in the class it is a part of.
3. Protected: can only be accessed from within the class or any object that inherits off of the class.

When using Encapsulation in C#
1. Separate public interface and private implementation:
	Access modifiers: public, private, protected
2. Client code only depends on public interface:
	Client should not know the details of implementation
3. Facilitates code maintenance and extensibility
	Changes on a class's implementation will not affect its client.

Benefits of Loose Coupling
1. Flexibility: Easier to change and extend the system with new functionality.
2. Maintainability: Isolates changes, making it easier to update or fix bugs.
3. Testability: Simplifies unit testing by allowing the use of mock objects.
4. Reusability: Increases the reuse potential of individual components.

Techniques to Achieve Loose Coupling
+ Interfaces and Abstract Classes: Use interfaces or abstract classes to define contracts between components.
+ Dependency Injection: Inject dependencies rather than creating them directly.
+ Event Handling and Callbacks: Use events and delegates to decouple components.
+ Service Locator Pattern: Use a service locator to resolve dependencies at runtime.
By aiming for loose coupling in your C# applications, you can create more modular, maintainable, and adaptable systems.

When using inheritance in C#:
1. A class can extend to another class:
	+ Inherit all attributes (fields) and behaviours (methods)
	+ It can introduce its own fields and methods
2. Is-a relation between subclass and superclasses:
	Ex: a Male is a Person. A Female is a Person.
3. Subclassing is transitive:
	Ex: a PinkLady is an Apple, and an Apple is a Fruit => A PinkLady is a Fruit.

Advantages of Dynamic Binding
1. Flexibility: Dynamic binding allows for more flexible and adaptable code, accommodating changes more easily.
2. Interoperability: It is useful when interacting with COM objects, dynamic languages, or other environments where types are not known at compile time.
3. Polymorphism: Enhances polymorphic behavior by allowing objects to be treated uniformly while their specific behavior is determined at runtime.

1. Disadvantages of Dynamic Binding
1. Performance: Runtime type checking and method resolution can introduce performance overhead.
2. Type Safety: Bypassing compile-time type checking can lead to runtime errors that are harder to debug.
3. Maintainability: Code that relies heavily on dynamic binding can be more difficult to understand and maintain.
=> Dynamic binding is a powerful feature in C# that, when used appropriately, can greatly enhance the flexibility and capability of your code.

Why dynamic binding? 
Client code can be reused, irrespective of the actual type of the target object.
Different types of objects may share a common superclass or interface.
Variables of the common supertype may refer to those different types of objects.
The different types may override the method definitions in their own way.

Single & Multiple inheritance:
1. Single inheritance:
	+ Every class has at most one parent class
		+ tree-based classification hierarchy:
		- assumming a topmost class
		- otherwise a forest-based classification	
2. Multiple inheritance:
	+ Combine more than one parent class.
	+ Major question ariese with multiple inheritance:
		- The main problem: the clash of names
		- Two parents contain methods with the same name ( and type signature), a PL must choose how to handle this case.
		- What to do with features with the same name inherited from different parents?
		- Copy or merge features?
		- Different languages have different rules for handling multiple inheritance

C# has 2 kinds of inheritances:
1. Class extension: A class may extent at most one other class or a class may implement multiple interfaces.
2. Interface implementation: An interface is a group of related methods with empty bodies (no field or method body)

Abstract class in C# (Lớp trừu tượng)
1. Abstract class may have abstract methods:
	+ Abstract methods have no method body
	+ Subclass must implement all abstract methods, otherwise, it is also an abstract class.
2. Abstract classes cannot be instantiated
	+ Abstract classes cannot be instantiated.
3. Abstract classes may have properties and concrete methods:
	+ A class extends exactly one abstract class

Software design principles
	+ A guidelines to help us avoid having a bad design.
	+ Bad design:
		- Rigidity: The software is hard to change, because every change affects too many other parts of the systems.
		- Fragility: When you make a change, unexpected parts of the system break.
		- Immobility: The code is hard to reuse in another application because it cannot be disentangled (gỡ rối) from the current application.

Software design principles:
1. SOLID
	+ is a mnemonic acronym for 5 design principles intended to make software designs more understandable, flexible, and maintainable.
	+ apply to any object-oriented design
	+ form a core philosophy for agile or adaptive software development methodologies.
	+ S: Single responsibility principle
2. DRY
3. KISS
4. YAGNI

sources:
1. https://200lab.io/blog/solid-la-gi-vai-tro-cua-solid-trong-oop/#:~:text=Single%20Responsibility%20Principle%20(SRP),-%22A%20class%20should&text=Nguy%C3%AAn%20t%E1%BA%AFc%20SRP%20%C4%91%C6%B0%E1%BB%A3c%20hi%E1%BB%83u,v%E1%BB%A5%20duy%20nh%E1%BA%A5t%20m%C3%A0%20th%C3%B4i.

SOLID single responsibility principle:
+ Every module should have responsibility for a single part of the functionality provided by the software.
+ The module should entirely encapsulate the responsibility.
	All its services should be narrowly aligned with that responsibility.
	A module should have only one reason to change.

SOLID
	+ Single responsibility principle: (nguyên tắc đơn nhiệm) - SRP
		A module should only have a single responsibility
		It is important to keep a Class focused on a single concern because it makes the class more robust
		A good design would place these two responsibilities into two different classes
		Mỗi class chỉ nên đảm nhiệm 1 nhiệm vụ duy nhất mà thôi
		Nếu 1 class có nhiều hơn 1 nhiệm vụ trong chương trình, thì cách tốt nhất là nên tách nó thành nhiều Class khác nhau
		Khi cần chỉnh sửa 1 chức năng nào đó, bạn chỉ cần chỉnh sửa trong chính Class đảm nhiệm chức năng đó mà không ảnh hưởng tới Class khác hoặc chương trình.
		Lưu ý: 
			- Việc tách 1 Class có nhiều nhiệm vụ thành nhiều Class khác nhau, không đồng nghĩa với việc tách các phương thức (method) thành từng Class riêng biệt.
			- Mỗi Class đảm trách 1 nhiệm vụ có thể có nhiều phương thức khác nhau
			- Việc nhóm các phương thức cùng giải quyết 1 nhiệm vụ về 1 Class đòi hỏi kiến thức và kinh nghiệm
	+ Open-closed principle (Nguyên tắc mở/đóng) - OCP
		Software entities should be open for extension but closed for modification
		Open for extension 
			+ A module will be said to be open if it is still available for extension
			+ A new functionality can be added only when new requirements are generated
		Closed for modification
			+ A module will be said to be closed if it is available for use by other modules.
			+ This assumes that the module has been given a well-defined, stable description (the interface in the sense of information hiding)
			+ Do not alter a developed and well-tested class until we find bugs.
		Use inheritance
			+ to extend a class without modifying it
		Các Class hoàn chỉnh, phải có khả năng mở rộng mà không cần chỉnh sửa chính Class đó.
		Để làm được vậy, chúng ta có thể sử dụng Inheritance, Interface hoặc Composition.
	+ Liskov substitution principle (Nguyên lý thay thế) - LSP
		Objects should be replaceable with instances of their subtypes without altering the correctness of program
		The principle is just an an extension of the Open Close Principle in terms of behaviour, 
		meaning that we must take that new derived classes are extending the base classes without changing their behaviour.
		Consider the following:
			- It is a particular definition of subtyping relations, with stronger behavioural subtyping
			- Derived types must be substitutable for their base type without altering of the desirable program properties (ex correctness, task performed)
		2 common ways to implement to solve the conflit:
			+ Simple return a null
			+ Throw an exception, letting the client handle it.
	+ Interface segregation principle (Phân chia Interface)
		No client should be forced to depend on methods it does not use
		Clients will only have to know about the medthods that are of interests to them
		This principle teaches us to take care of how we write our interfaces.
		When we write our interfaces we should take care to add only methods that should be there.
		If we add methods that should not be there, the classes implementing the interface will have to implement those methods as well.
		The good design would place these operations into different interfaces, so that they can be implemented only when needed. 
	+ Dependency inversion principle (Đảo ngược phụ thuộc)
		One should depend upon abstractions, not concretions
		In other words, you need to decouple high-level and low-level classes.
		Usually: 
			+ High-level classes encapsulate complex logic 
			+ Low-level classes include data or utilities.
		According to the Dependency Inversion Principle:
			+ Need to invert the dependency
		Otherwise, when the low-level class is replaced, the high-level class will be affected,too.
		=> By dictating that both high-level and low-level objects must depend on the same abstraction,
		This design principle inverts the way some people may think about object-oriented programming (Discussed later)
		Why is the dependency inverted?
		In this implementation, high-level components and low-level components are distributed into separate packages/libraries, 
		where the interfaces defining the behaviour/services required by the high-level component are owned by and exist within the high-level component's library. 
		The implementation of the high-level component's interface by the low-level component requires that the low-level component package depends upon the high-level component for compilation,
		thus inverting the conventional dependency relationship.
DRY =  Don't Repeat Yourself
	Every piece of knowledge must have a single, unambigous, authoritative representation within the system.
	Reduce repetition of software patterns.
	Replace it with abstraction to avoid redundancy.
	If you must perform an operation twice, use the same code to do it.
KISS = Keep It Simple, Stupid
	Most systems work best if they are kept simple rather than made complicated.
	Simplicity should be a key goal in design.
	Unnecessary complexity should be avoided.
YAGNI = You Aren't Gonna Need It
	Always implement things when you actually need them, never when you just foresee that you need them.
	A programmer should not add functionally until deemed necessary.
	Save time - avoiding writing code that turns out to be not needed.
	Better code - avoiding polluting it with guesses that turn out to be more or less wrong but stick around anyway.


